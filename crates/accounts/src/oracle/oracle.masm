use.std::sys
use.miden::account
use.miden::tx

# ERRORS
# =================================================================================================

# Raised when an already registered publisher tries to register again.
const.ERR_PUBLISHER_ALREADY_REGISTERED=0x0002004A

# Raised when an unregistered publisher tries to publish data.
const.ERR_PUBLISHER_NOT_REGISTERED=0x0002004A

const.PUBLISHER_GET_ENTRY_HASH_0=1007391524189378068
const.PUBLISHER_GET_ENTRY_HASH_1=7679889649787278131
const.PUBLISHER_GET_ENTRY_HASH_2=9558208618383477329
const.PUBLISHER_GET_ENTRY_HASH_3=3591001968011231748

# CONSTANTS
# =================================================================================================

# Holds the next storage slot index available. Will be used when we register a publisher,
# so we can assign it a slot.
const.NEXT_PUBLISHER_INDEX_SLOT=0

# Holds the next storage slot index available. Will be used when we register a publisher,
# so we can assign it a slot.
const.PUBLISHER_REGISTRY_MAP_SLOT=1

#! Gets entry from the oracle's data slots.
#!
#! Inputs:  [publisher_id, pair]
#! Outputs: [WORD] ; Word being [pair, price, decimals, timestamp]
export.get_entry
    # Duplicate the publisher id for verification  
    dupw
    # => [publisher_id, publisher_id, pair]

    # Verifies if the publisher is registered, panics if not
    push.PUBLISHER_REGISTRY_MAP_SLOT exec.account::get_map_item
    # => [slot, publisher_id, pair]
    
    # Remove the slot id
    drop
    # => [publisher_id, pair]

    # Push the get_entry hash word (constant?)
    push.0x14160cfd40f9fa0d3313c559f272946a510ad3cb1894a58404c2099343cdd531
    # => [get_entry_hash, publisher_id, pair]

    swap.1
    # => [publisher_id, get_entry_hash, pair]

    exec.tx::execute_foreign_procedure
    # => [entry]

    # Truncate if necessary
    exec.sys::truncate_stack
end

#! Gets the median price of a given asset.
#!
#! Inputs:  [ASSET]
#! Outputs: [PRICE]
#!
export.get_median
    # 1. iterate from 2 to NEXT_PUBLISHER_INDEX_SLOT value.

    # 2. for each slot, get the publisher id and call get_entry.

    # 3. sort the entries, see sorting algorithms here: https://github.com/0xPolygonMiden/examples/pulls

    # 4. compute median

    # 5. return median

    # 6. increments the nonce (anyone should be able to call that function)
    push.1 exec.account::incr_nonce

    dropw
end

#! Registers a new publishers into the Oracle.
#! Can only be called by the Owner of the Oracle account.
#! Will reserve a storage slot for the publisher if it's not already registered,
#! which mean this publisher will be able to publish data.
#!
#! Inputs:  [publisher_id]
#! Outputs: []
#!
export.register_publisher
    # check if it is not already present in the registry, if yes raise err (get_map_item)
    
    # assign NEXT_PUBLISHER_INDEX_SLOT to the caller and store in the registry map (set_map_item)
    push.NEXT_PUBLISHER_INDEX_SLOT exec.account::get_item
    # => [next_publisher_slot, publisher_id]

    # increment NEXT_PUBLISHER_INDEX_SLOT
    add.1
    push.PUBLISHER_REGISTRY_MAP_SLOT exec.account::set_item

    # Only the oracle owner should be able to call this
    call.::miden::contracts::auth::basic::auth_tx_rpo_falcon512
    drop
end
